# Notes on sorting algorithms
# 1. Bubble Sort: O(n^2) time complexity, O(1) space complexity, stable, in-place
# 2. Selection Sort: O(n^2) time complexity, O(1) space complexity, not stable, in-place
# 3. Insertion Sort: O(n^2) time complexity, O(1) space complexity, stable, in-place
# 4. Quick Sort: O(n log n) average time complexity, O(log n) space complexity, not stable, in-place
# 5. Merge Sort: O(n log n) time complexity, O(n) space complexity, stable, not in-place
# 6. Heap Sort: O(n log n) time complexity, O(1) space complexity, not stable, not in-place
# 7. Counting Sort: O(n + k) time complexity, O(k) space complexity, stable, not in-place
# 8. Radix Sort: O(n * k) time complexity, O(n + k) space complexity, stable, not in-place
# 9. Bucket Sort: O(n + k) time complexity, O(n) space complexity, stable, not in-place
# 10. Tim Sort: O(n log n) time complexity, O(n) space complexity, stable, not in-place
# 11. Shell Sort: O(n log n) time complexity, O(1) space complexity, not stable, in-place
# 12. Comb Sort: O(n log n) time complexity, O(1) space complexity, not stable, in-place
# 13. Cocktail Sort: O(n^2) time complexity, O(1) space complexity, stable, in-place
# 14. Gnome Sort: O(n^2) time complexity, O(1) space complexity, stable, in-place
# 15. Bitonic Sort: O(n log^2 n) time complexity, O(n) space complexity, stable, not in-place
# 16. Odd-Even Sort: O(n^2) time complexity, O(1) space complexity, stable, in-place


# Now let's rank them in terms of Time complexity: we will als consider the best, average and worst cases for each algorithm. but we first consider the worst case for each one then we will consider the best and average cases iif two algorithms have the same worst cases
# 1. The best one: 

